<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hzscoder&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-23T07:23:31.518Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hzscoder</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android Touch事件拦截处理机制</title>
    <link href="http://yoursite.com/2019/01/22/Android%20onTouchEvent%E4%BA%8B%E4%BB%B6%E6%8B%A6%E6%88%AA%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/01/22/Android onTouchEvent事件拦截处理机制/</id>
    <published>2019-01-22T11:20:46.000Z</published>
    <updated>2019-01-23T07:23:31.518Z</updated>
    
    <content type="html"><![CDATA[<p>Android的Touch事件在三个方法中进行分发，拦截，处理。分别是：</p><ul><li>事件分发  public boolean dispatchTouchEvent(MotionEvent ev)</li><li>事件拦截  public boolean onInterceptTouchEvent(MotionEvent ev)</li><li>事件处理  public boolean onTouchEvent(MotionEvent ev)<a id="more"></a></li></ul><p>android系统中每个View都具有这三个方法。Touch事件由ViewGroup和View完成分发拦截和处理。当Activity接收到TouchEvent事件时，调用它内部的ViewGroup对Touch事件进行分发。首先将事件传递给最顶层的ViewGroup，调用dispatchTouchEvent方法，该方法遍历其子ViewGroup或View的dispatchTouchEvent方法。</p><p>如果子View的dispatchTouchEvent方法返回true，则将事件分发给该View；如果返回false，则调用该View的onInterceptTouchEvent方法根据返回值来决定时是否拦截。若拦截，则分发结束；若不拦截，则继续遍历dispatchTouchEvent方法进行分发，直到分发结束，如果子View都不响应，则由Activity自己处理。</p><p>如果分发给某一子View，则会响应该View的onTouchEvent方法。执行完毕若返回true，则表示消费掉该touch事件。返回false则让事件向上层View继续传递，且这时候都是由onTouchEvent方法来接收，以此类推。但如果所有的onTouchEvent都返回false，那么这个时间便会消失，且接收不到下次事件。这就是为什么会说事件分发是从外到内，而事件的执行是从内到外了。</p><p>说到这里，似乎只要我们把所有的onTouchEvent都返回false，就能保证所有的子控件都响应本次Touch事件了。其实不然，这里的Touch事件，只限于Acition_Down事件，即触摸按下事件,而Aciton_UP和Action_MOVE却不会执行。一次完整的Touch事件，应该是由一个Down、一个Up和若干个Move组成的。事件分发的目的就是找到需要处理整个Touch事件的View。</p><p>注：如果在DOWN事件响应时返回了false，有可能导致系统认为你已经处理完成，后面的MOVE和UP事件都不会响应。</p><p>最后，谈谈使用onClick的心得。<br>1.在设置了onClick监听器的情况下，View的clickable状态自动置为true。<br>2.onClick事件响应完成后，默认会被消耗掉。<br>3.在同时设置onClickListener和onTouchListener时，onTouch事件优先级更高，返回true的话，onclick得不到执行；但返回false的话，onclik可以执行。</p><p>贴上三个方法的效果。<br>(1) 事件分发: public boolean dispatchTouchEvent(MotionEvent ev)<br>当Touch事件发生时，Activity的dispatchTouchEvent()方法会以隧道方式(从根节点依次往下传递直到最内层子节点，或在中间某一节点中由于某一条件停止传递)将事件传递给最外层View的dispatchTouchEvent()方法，并由该View的dispatchTouchEvent()方法对事件进行分发。</p><ul><li>return true ：事件会分发给当前View并由dispatchTouchEvent()方法进行消费，同时事件会停止向下传递。</li><li>return false ：将事件返还给当前View的上一级的onTouchEvent()进行消费。(这个上一级可能是Activity，也可能是父View)</li><li>return super.dispatchTouchEvent(ev) ：事件会自动的分发给当前View的onInterceptTouchEvent方法。</li></ul><p>(2) 事件拦截: public boolean onInterceptTouchEvent(MotionEvent ev)<br>拦截事件，阻止事件的分发。</p><ul><li>return true ：将对事件进行拦截，并将拦截到的事件交由当前View的onTouchEvent()进行处理。</li><li>return false ：将对事件进行放行，当前View上的事件会被传递到子View 上，再由子View的dispatchTouchEvent()来继续对这个事件进行分发。</li><li>return super.onInterceptTouchEvent(ev) ：事件默认会被拦截，并将拦截到的事件交由当前View的onTouchEvent()进行处理。</li></ul><p>(3) 事件响应: public boolean onTouchEvent(MotionEvent ev)<br>响应事件，做出相应的处理。</p><ul><li>return false ：事件将会从当前View向上传递，并且都是由上层View的onTouchEvent()来接收。</li><li>return true ：接收并消费掉该事件。</li><li>return super.onTouchEvent(ev) ：默认处理事件的逻辑和return false相同。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Android的Touch事件在三个方法中进行分发，拦截，处理。分别是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件分发  public boolean dispatchTouchEvent(MotionEvent ev)&lt;/li&gt;
&lt;li&gt;事件拦截  public boolean onInterceptTouchEvent(MotionEvent ev)&lt;/li&gt;
&lt;li&gt;事件处理  public boolean onTouchEvent(MotionEvent ev)
    
    </summary>
    
      <category term="Android学习" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android 原理" scheme="http://yoursite.com/tags/Android-%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Android浅析DrawerLayout使用ActionBarDrawerToggle实现侧滑菜单动画</title>
    <link href="http://yoursite.com/2019/01/12/Android%E6%B5%85%E6%9E%90DrawerLayout%E4%BD%BF%E7%94%A8ActionBarDrawerToggle%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95%E5%8A%A8%E7%94%BB/"/>
    <id>http://yoursite.com/2019/01/12/Android浅析DrawerLayout使用ActionBarDrawerToggle实现侧滑菜单动画/</id>
    <published>2019-01-12T09:25:59.172Z</published>
    <updated>2019-01-23T07:15:48.428Z</updated>
    
    <content type="html"><![CDATA[<p>ActionBarDrawerLayoutToggle可以将DrawerLayout和ActionBar框架结合在一起实现侧滑菜单滑动时的动画效果。符合Google提出的Material Design设计风格。<br><a id="more"></a><br>首先，DrawLayout实现点击出现侧滑菜单可以用点击HomeAsUp按钮实现。可以在Activity里重写onOptionsItemSelected()方法为HomeAsUp按钮设置监听器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onOptionsItemSelected</span><span class="params">(MenuItem item)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(item.getItemId())&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">case</span> android.R.id.home:</span><br><span class="line">                drawerLayout.openDrawer(GravityCompat.START);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>注：HomeAsUp按钮的id永远是android.R.id.home。</p><p>另外，HomeAsUp按钮的默认图标是一个向左的箭头，可以对图标样式进行更改。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">actionBar.setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</span><br><span class="line">actionBar.setHomeAsUpIndicator(R.drawable.ic_picture);<span class="comment">//ic_picture是替换的图片</span></span><br></pre></td></tr></table></figure></p><p>设置动画的话，须在Activity里创建一个ActionBarDrawerLayoutToggle用来监视DrawerLayout的状态，然后根据DrawLayout的状态来改变DrawerArrowDrawable的绘制状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ActionBarDrawerToggle actionBarDrawerToggle = <span class="keyword">new</span> ActionBarDrawerToggle(<span class="keyword">this</span>, drawerLayout,toolbar, <span class="number">0</span> ,<span class="number">0</span>);</span><br><span class="line">drawerLayout.addDrawerListener(actionBarDrawerToggle);</span><br><span class="line">actionBarDrawerToggle.syncState();</span><br></pre></td></tr></table></figure></p><p>其中，先调用ActionBarDrawerToggle的构造函数。如果使用ActionBar，该方法接收4个参数，如果使用ToolBar，则是5个，参数分别是托管Drewerlayout的活动、需要绑定的DrawerLayout、ToolBar、和两个String资源(int)用于描述可访问性的打开侧滑菜单操作，默认可传递0。<br>然后，调用DrawerLayout.addDrawerListener()方法将DrawLayout与ActionBarDrawerToggle绑定在一起。<br>最后调用ActionBarDrawerToggle.syncState()方法将ActionBarDrawerToggle与绑定的DrawerLayout状态同步。不过安卓开发文档上Google推荐的写法写在Activity的onPostCreate()回调方法里。如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPostCreate</span><span class="params">(Bundle savedInstanceState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPostCreate(savedInstanceState);</span><br><span class="line">        actionBarDrawerToggle.syncState();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>进去看addDrawerListener()的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addDrawerListener</span><span class="params">(@NonNull DrawerLayout.DrawerListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.mListeners == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.mListeners = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">this</span>.mListeners.add(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中将drawerLayout的监听器设置为了ActionBarDrawerToggle，ActionBarDrawerToggle实现了DrawerLayout.DrawerListener接口。</p><p>点进去DrawerLayout.DrawerListener<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DrawerListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onDrawerSlide</span><span class="params">(@NonNull View var1, <span class="keyword">float</span> var2)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onDrawerOpened</span><span class="params">(@NonNull View var1)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onDrawerClosed</span><span class="params">(@NonNull View var1)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onDrawerStateChanged</span><span class="params">(<span class="keyword">int</span> var1)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>该接口有四个成员方法。分别对应侧滑菜单滑动、打开、关闭、状态改变的四个回调方法。<br>点开ActionBarDrawerToggle的onDrawerSlide()方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawerSlide</span><span class="params">(View drawerView, <span class="keyword">float</span> slideOffset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mDrawerSlideAnimationEnabled) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setPosition(Math.min(<span class="number">1.0F</span>, Math.max(<span class="number">0.0F</span>, slideOffset)));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.setPosition(<span class="number">0.0F</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其中第二个参数是滑动的偏移量，范围是0F到1F，可以看到，将偏移量传递给了setPosition()函数，继续跟踪该方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPosition</span><span class="params">(<span class="keyword">float</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (position == <span class="number">1.0F</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mSlider.setVerticalMirror(<span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position == <span class="number">0.0F</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mSlider.setVerticalMirror(<span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.mSlider.setProgress(position);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>mSlider是DrawerArrowDrawable的一个实例，DrawerArrowDrawable继承自Drawable，是动画的具体样式。这里，根据偏移量的值，选择调用setVerticalMirror()和setProgress()方法。继续跟踪分析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVerticalMirror</span><span class="params">(<span class="keyword">boolean</span> verticalMirror)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mVerticalMirror != verticalMirror) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mVerticalMirror = verticalMirror;</span><br><span class="line">            <span class="keyword">this</span>.invalidateSelf();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProgress</span><span class="params">(@FloatRange(from = <span class="number">0.0</span>D,to = <span class="number">1.0</span>D)</span> <span class="keyword">float</span> progress) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.mProgress != progress) &#123;</span><br><span class="line">            <span class="keyword">this</span>.mProgress = progress;</span><br><span class="line">            <span class="keyword">this</span>.invalidateSelf();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>两个函数都调用了Drawable的invalidateSelf()方法进行重绘。<br>setVerticalMirror()根据传入参数的不同选择将canvas翻转到动画开始或者结束的画面，对应侧滑菜单动画的开始和结束。<br>setProgress()根据偏移量设置滑动的进度然后进行重绘。</p><p>讲到这里，更改HomeAsUp按钮图标时如果要设置成三条横线的图标时有个简单的方法。在setHomeAsUpIndicator()方法里传入DrawerArrowDrawable的实例，会直接显示DrawerArrowDrawable的动画初始界面，也就是三条横线的样式。代码如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">actionBar.setDisplayHomeAsUpEnabled(<span class="keyword">true</span>);</span><br><span class="line">actionBar.setHomeAsUpIndicator(<span class="keyword">new</span> DrawerArrowDrawable(<span class="keyword">this</span>));</span><br></pre></td></tr></table></figure></p><p>另外，ActionBarDrawerToggle好像也有一个setHomeAsUpIndicator()方法，可以用来修改HomeAsUp图标样式，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">ActionBarDrawerToggle actionBarDrawerToggle = <span class="keyword">new</span> ActionBarDrawerToggle(<span class="keyword">this</span>, drawerLayout,</span><br><span class="line">toolbar, <span class="number">0</span> ,<span class="number">0</span>);</span><br><span class="line">actionBarDrawerToggle.setDrawerIndicatorEnabled(<span class="keyword">false</span>);</span><br><span class="line">actionBarDrawerToggle.setHomeAsUpIndicator(R.drawable.ic_menu); <span class="comment">//ic_menu为自己准备的图片</span></span><br><span class="line">actionBarDrawerToggle.setToolbarNavigationClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                drawerLayout.openDrawer(GravityCompat.START);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">drawerLayout.addDrawerListener(actionBarDrawerToggle);</span><br><span class="line">actionBarDrawerToggle.syncState();</span><br></pre></td></tr></table></figure></p><p>不过使用之前要调用setDrawerIndicatorEnabled()方法，并传入false，意思是让actionBarDrawerToggle不使用系统图标。而且，还要为其设置单独的监听器，不然没有点击效果。然后又因为没有使用定义好了的图标，这个没有侧滑菜单动画效果，个人感觉没啥用，也许是本人能力有限。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ActionBarDrawerLayoutToggle可以将DrawerLayout和ActionBar框架结合在一起实现侧滑菜单滑动时的动画效果。符合Google提出的Material Design设计风格。&lt;br&gt;
    
    </summary>
    
      <category term="Android UI" scheme="http://yoursite.com/categories/Android-UI/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android之RelativeLayout各属性含义</title>
    <link href="http://yoursite.com/2018/12/16/Android%E4%B9%8BRelativeLayout%E5%90%84%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89/"/>
    <id>http://yoursite.com/2018/12/16/Android之RelativeLayout各属性定义/</id>
    <published>2018-12-16T06:14:57.462Z</published>
    <updated>2019-01-23T07:15:48.383Z</updated>
    
    <content type="html"><![CDATA[<p>android:layout_above=”@id/xxx”  –将控件置于给定ID控件之上<br>android:layout_below=”@id/xxx”  –将控件置于给定ID控件之下<br><a id="more"></a></p><p>android:layout_toLeftOf=”@id/xxx”  –将控件的右边缘和给定ID控件的左边缘对齐<br>android:layout_toRightOf=”@id/xxx”  –将控件的左边缘和给定ID控件的右边缘对齐</p><p>android:layout_alignLeft=”@id/xxx”  –将控件的左边缘和给定ID控件的左边缘对齐<br>android:layout_alignTop=”@id/xxx”  –将控件的上边缘和给定ID控件的上边缘对齐<br>android:layout_alignRight=”@id/xxx”  –将控件的右边缘和给定ID控件的右边缘对齐<br>android:layout_alignBottom=”@id/xxx”  –将控件的底边缘和给定ID控件的底边缘对齐</p><p>android:layout_alignParentLeft=”true”  –将控件的左边缘和父控件的左边缘对齐<br>android:layout_alignParentTop=”true”  –将控件的上边缘和父控件的上边缘对齐<br>android:layout_alignParentRight=”true”  –将控件的右边缘和父控件的右边缘对齐<br>android:layout_alignParentBottom=”true” –将控件的底边缘和父控件的底边缘对齐</p><p>android:layout_centerInParent=”true”  –将控件置于父控件的中心位置<br>android:layout_centerHorizontal=”true”  –将控件置于水平方向的中心位置<br>android:layout_centerVertical=”true”  –将控件置于垂直方向的中心位置</p><p>注：本文转自<a href="https://blog.csdn.net/softkexin/article/details/5933589" target="_blank" rel="noopener">https://blog.csdn.net/softkexin/article/details/5933589</a><br>感谢博主分享</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;android:layout_above=”@id/xxx”  –将控件置于给定ID控件之上&lt;br&gt;android:layout_below=”@id/xxx”  –将控件置于给定ID控件之下&lt;br&gt;
    
    </summary>
    
      <category term="Android学习" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android O 发送通知</title>
    <link href="http://yoursite.com/2018/11/27/Android%20O%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2018/11/27/Android O发送通知方法/</id>
    <published>2018-11-27T11:39:02.890Z</published>
    <updated>2019-01-23T07:20:04.768Z</updated>
    
    <content type="html"><![CDATA[<p>几乎Android系统的每一个版本都会对通知这部分功能进行或多或少的修改，API不稳定性在通知上面突显的尤为严重。<br><a id="more"></a></p><p>首先，我们先回顾下Android N发送通知的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NotificationManager manager=(NotificationManager)</span><br><span class="line">                getSystemService(Context.NOTIFICATION_SERVICE);</span><br><span class="line">        Notification notification=<span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>)</span><br><span class="line">                .setContentTitle(<span class="string">"this is a title"</span>)</span><br><span class="line">                .setContentText(<span class="string">"this is text"</span>)</span><br><span class="line">                .setWhen(System.currentTimeMillis())</span><br><span class="line">                .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher))</span><br><span class="line">                .build();</span><br><span class="line">        manager.notify(<span class="number">1</span>,notification);</span><br></pre></td></tr></table></figure></p><p>首先用NotificationCompat.Builder()构造一个NotificationManager,然后对创建的通知notify(),notify()接收两个参数，第一个参数是id(保证每个通知的id不同即可)，第二个参数则是Notification对象。</p><p>而Android O弃用了NotificationCompat.Builder(Context)函数,被NotificationCompat.builder(Context,String)所取代，其中第二个String参数是渠道id。如果用户环境低于Android O，第二个参数将被忽略。</p><p>从Android 8.0系统开始，Google引入了通知渠道这个概念。</p><p>什么是通知渠道呢？顾名思义，就是每条通知都要属于一个对应的渠道。开发者可以自由地创建当前App拥有哪些通知渠道，但是这些通知渠道的控制权都是掌握在用户手上的。用户可以自由地选择这些通知渠道的重要程度，是否响铃、是否振动、或者是否要关闭这个渠道的通知。拥有了这些控制权之后，用户就再也不用害怕那些垃圾推送消息的打扰了，因为用户可以自主地选择自己关心哪些通知、不关心哪些通知。</p><p>举个具体的例子，我希望可以即时收到支付宝的收款信息，因为我不想错过任何一笔收益，但是我又不想收到支付宝给我推荐的周围美食，因为我没钱只吃得起食堂。这种情况，支付宝就可以创建两种通知渠道，一个收支，一个推荐，而我作为用户对推荐类的通知不感兴趣，那么我就可以直接将推荐通知渠道关闭，这样既不影响我关心的通知，又不会让那些我不关心的通知来打扰我了。</p><p>源代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="comment">//创建通知渠道</span></span><br><span class="line">        <span class="keyword">if</span>(Build.VERSION.SDK_INT&gt;=Build.VERSION_CODES.O)&#123;</span><br><span class="line">            String channelId1=<span class="string">"chat"</span>;</span><br><span class="line">            String channelName1=<span class="string">"聊天消息"</span>;</span><br><span class="line">            NotificationChannel channel1=<span class="keyword">new</span> NotificationChannel(channelId1,channelName1,</span><br><span class="line">                    NotificationManager.IMPORTANCE_HIGH);</span><br><span class="line">            channel1.setShowBadge(<span class="keyword">true</span>);</span><br><span class="line">            String channelId2=<span class="string">"subscribe"</span>;</span><br><span class="line">            String channelName2=<span class="string">"订阅消息"</span>;</span><br><span class="line">            NotificationChannel channel2=<span class="keyword">new</span> NotificationChannel(channelId2,channelName2,</span><br><span class="line">                    NotificationManager.IMPORTANCE_DEFAULT);</span><br><span class="line">            channel2.setShowBadge(<span class="keyword">true</span>);</span><br><span class="line">            NotificationManager manager=(NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">            manager.createNotificationChannel(channel1);</span><br><span class="line">            manager.createNotificationChannel(channel2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * send message</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendChatMsg</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        NotificationManager manager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">            NotificationChannel channel = manager.getNotificationChannel(<span class="string">"chat"</span>);</span><br><span class="line">            <span class="keyword">if</span> (channel.getImportance() == NotificationManager.IMPORTANCE_NONE) &#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);</span><br><span class="line">                intent.putExtra(Settings.EXTRA_APP_PACKAGE, getPackageName());</span><br><span class="line">                intent.putExtra(Settings.EXTRA_CHANNEL_ID, channel.getId());</span><br><span class="line">                startActivity(intent);</span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>, <span class="string">"请手动将通知打开"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Notification notification=<span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>,<span class="string">"chat"</span>)</span><br><span class="line">                .setContentTitle(<span class="string">"收到一条聊天消息"</span>)</span><br><span class="line">                .setContentText(<span class="string">"hello"</span>)</span><br><span class="line">                .setWhen(System.currentTimeMillis())</span><br><span class="line">                .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher))</span><br><span class="line">                .setAutoCancel(<span class="keyword">true</span>)</span><br><span class="line">                .setNumber(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line">        manager.notify(<span class="number">1</span>,notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSubscribeMsg</span><span class="params">(View view)</span></span>&#123;</span><br><span class="line">        NotificationManager manager=(NotificationManager)getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">        Notification notification=<span class="keyword">new</span> NotificationCompat.Builder(<span class="keyword">this</span>,<span class="string">"subscribe"</span>)</span><br><span class="line">                .setContentTitle(<span class="string">"收到一条订阅消息"</span>)</span><br><span class="line">                .setContentText(<span class="string">"Vans高帮鞋大力促销中"</span>)</span><br><span class="line">                .setWhen(System.currentTimeMillis())</span><br><span class="line">                .setSmallIcon(R.mipmap.ic_launcher)</span><br><span class="line">                .setLargeIcon(BitmapFactory.decodeResource(getResources(),R.mipmap.ic_launcher))</span><br><span class="line">                .setAutoCancel(<span class="keyword">true</span>)</span><br><span class="line">                .setNumber(<span class="number">1</span>)</span><br><span class="line">                .build();</span><br><span class="line">        manager.notify(<span class="number">2</span>,notification);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>布局文件中只有两个按钮，代码中sendChaMsg和sendSubscribeMsg分别为两个按钮的点击事件。</p><p>可以看到，我首先在onCreate函数里面创建了两个渠道并设定相应的优先级，渠道id分别为chat和subscribe，然后再点击事件里面创建通知，创建通知时应该说明该通知属于哪一个渠道，在NotificationCompat.Builder构造时传入相应的渠道id。最后通过NotificationManager发送。</p><p>注:<br>在老版本中构造通知时使用的是Notification，<br>新版本使用的是Notification.Builder,<br>从Android 7.0开始，Android在appcompat-v7库中提供了一个NotificationCompat类来处理新老版本的兼容问题。</p><p>其中创建channel时，还调用了Channel.setShowBadge函数，目的是让该渠道发送的消息在应用图标上显示未读角标。发送消息时在NotificationCompat.Builder中调用setNumber(int number)即可显示未读数量,可以调用setBadgeIconType(int icon)设置角标样式，不设置为默认样式。</p><p>另外，Android还赋予了开发者读取通知渠道配置的权限。如果用户不小心将某个很重要的渠道发送通知的开关给关闭了，这时候就可以提示用户手动去更改消息渠道开关。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (channel.getImportance() == NotificationManager.IMPORTANCE_NONE) &#123;</span><br><span class="line">                Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_CHANNEL_NOTIFICATION_SETTINGS);</span><br><span class="line">                intent.putExtra(Settings.EXTRA_APP_PACKAGE, getPackageName());</span><br><span class="line">                intent.putExtra(Settings.EXTRA_CHANNEL_ID, channel.getId());</span><br><span class="line">                startActivity(intent);</span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>, <span class="string">"请手动将通知打开"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><p>附:<br>NotificationChannel方法列表</p><ul><li>getId() —  获取 ChannleId</li><li>enableLights() —  开启指示灯，如果设备有的话。</li><li>setLightColor() —  设置指示灯颜色</li><li>enableVibration() —  开启震动</li><li>setVibrationPattern() —  设置震动频率</li><li>setImportance() —  设置频道重要性</li><li>getImportance() —  获取频道重要性</li><li>setSound() —  设置声音</li><li>getSound() —  获取声音</li><li>setGroup() —  设置 ChannleGroup</li><li>getGroup() —  得到 ChannleGroup</li><li>setBypassDnd() —  设置绕过免打扰模式</li><li>canBypassDnd() —  检测是否绕过免打扰模式</li><li>getName() —  获取名称</li><li>setLockScreenVisibility() —  设置是否应在锁定屏幕上显示此频道的通知</li><li>getLockscreenVisibility() —  检测是否应在锁定屏幕上显示此频道的通知</li><li>setShowBadge() 设置是否显示角标</li><li>canShowBadge() —  检测是否显示角标</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几乎Android系统的每一个版本都会对通知这部分功能进行或多或少的修改，API不稳定性在通知上面突显的尤为严重。&lt;br&gt;
    
    </summary>
    
      <category term="Android学习" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>AS更新后AndroidManifest提示warning应用程序无法通过Google搜索进行索引</title>
    <link href="http://yoursite.com/2018/11/25/AS%E6%9B%B4%E6%96%B0%E5%90%8Ewarning%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%97%A0%E6%B3%95%E9%80%9A%E8%BF%87Google%E6%90%9C%E7%B4%A2%E8%BF%9B%E8%A1%8C%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2018/11/25/AS更新后warning应用程序无法通过Google搜索进行索引/</id>
    <published>2018-11-25T06:26:14.600Z</published>
    <updated>2019-01-23T07:15:43.364Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个自认为有强迫症的低端Coder，上次还是忍不住把AS更新了。<br>结果新版本用起来了一大堆各种各样的问题。其中有一个就是AndroidManifest文件中多了一个warning<br><a id="more"></a></p><p>App is not indexable by Google Search;<br>consider adding at least one Activity with an ACTION-VIEW</p><p>官方文档是这么说的:<br>To enable Google to crawl your app content and allow users to enter your app from search results, you must add intent filters for the relevant activities in your app manifest. These intent filters allow deep linking to the content in any of your activities. For example, the user might click on a deep link to view a page within a shopping app that describes a product offering that the user is searching for</p><p>要使Google能够抓取您的应用内容并允许用户从搜索结果中输入您的应用，您必须为应用清单中的相关活动添加意图过滤器。这些意图过滤器允许深入链接到您的任何活动中的内容。例如，用户可以点击深层链接以查看购物应用中的页面，该页面描述用户正在搜索的产品</p><p>解决方法有以下两个：</p><p>1.在AndroidManifest文件Activity标签中内嵌入一个ACTION.VIEW，如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">".MainActivity"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">                <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>2.禁用检索功能，在app目录下build.gradle文件中android闭包中加入以下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lintOptions &#123;</span><br><span class="line">        disable <span class="string">'GoogleAppIndexingWarning'</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为一个自认为有强迫症的低端Coder，上次还是忍不住把AS更新了。&lt;br&gt;结果新版本用起来了一大堆各种各样的问题。其中有一个就是AndroidManifest文件中多了一个warning&lt;br&gt;
    
    </summary>
    
      <category term="Android学习" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android学习之内存泄露</title>
    <link href="http://yoursite.com/2018/11/24/Android%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>http://yoursite.com/2018/11/24/Android学习之内存泄露/</id>
    <published>2018-11-24T11:53:20.026Z</published>
    <updated>2019-01-23T07:15:48.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="产生内存泄露的根本原因以及影响"><a href="#产生内存泄露的根本原因以及影响" class="headerlink" title="产生内存泄露的根本原因以及影响"></a>产生内存泄露的根本原因以及影响</h3><p>当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏<br><a id="more"></a></p><p>内存泄漏是造成应用程序OOM的主要原因之一。我们知道Android系统为每个应用程序分配的内存是有限的，而当一个应用中产生的内存泄漏比较多时，这就难免会导致应用所需要的内存超过系统分配的内存限额，这就造成了内存溢出从而导致应用Crash，可以借助MAT、LeakCanary等工具来检测应用程序是否存在内存泄漏</p><h4 id="1-资源未释放或对象内存过大"><a href="#1-资源未释放或对象内存过大" class="headerlink" title="1. 资源未释放或对象内存过大"></a>1. 资源未释放或对象内存过大</h4><p>程序长期保持某些资源，如Context、Cursor、IO 流的引用，资源得不到释放造成内存泄露。或者程序保存了多个耗用内存过大的对象（如Bitmap、XML 文件），造成内存超出限制</p><h4 id="2-非静态内部类造成内存泄露"><a href="#2-非静态内部类造成内存泄露" class="headerlink" title="2.非静态内部类造成内存泄露"></a>2.非静态内部类造成内存泄露</h4><p>非静态内部类和匿名类内部类都会持有它们所属的外部类的引用，但是静态内部类不会</p><h5 id="nbsp-nbsp-nbsp-nbsp-1-匿名内部类创建线程内存泄露"><a href="#nbsp-nbsp-nbsp-nbsp-1-匿名内部类创建线程内存泄露" class="headerlink" title="&nbsp; &nbsp; &nbsp; &nbsp; 1).匿名内部类创建线程内存泄露"></a>&nbsp; &nbsp; &nbsp; &nbsp; 1).匿名内部类创建线程内存泄露</h5><p>我们创建线程的时候通常采用内部类写法。但是我们思考一个问题:假设我们在Activity里面创建了一个线程，但Thread里的run函数是一个很费时的操作。当我们开启该线程后，Activity因为某些情况被重新创建(例如用户将设备竖屏变为了横屏，一般情况下当屏幕转换时会重新创建Activity)。按照我们的想法，原来的Activity应该会被销毁才对，然而事实上并非如此。因为我们创建的Thread是Activity的内部类，所以Thread中保存了Activity的一个引用，当Thread的run函数没有结束时，线程是不会被销毁的。因此它所引用的原来的那个Activity也是不会被销毁，因此就出现了内存泄露的问题。</p><h5 id="nbsp-nbsp-nbsp-nbsp-2-创建内部类Handler内存泄露"><a href="#nbsp-nbsp-nbsp-nbsp-2-创建内部类Handler内存泄露" class="headerlink" title="&nbsp; &nbsp; &nbsp; &nbsp; 2).创建内部类Handler内存泄露"></a>&nbsp; &nbsp; &nbsp; &nbsp; 2).创建内部类Handler内存泄露</h5><p>示例代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                handler.sendEmptyMessage(<span class="number">0x123</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当Android应用程序启动时，该应用程序的主线程会自动创建一个Looper对象和与之关联的MessageQueue。当主线程中实例化一个Handler对象后，它就会自动与主线程Looper的MessageQueue关联起来。所有发送到MessageQueue的Messag都会持有Handler的引用，所以Looper会据此回调Handle的handleMessage()方法来处理消息。只要MessageQueue中有未处理的Message，Looper就会不断的从中取出并交给Handler处理。另外，主线程的Looper对象会伴随该应用程序的整个生命周期。所以当MainActivity结束时，未处理的消息持有handler的引用，而handler又持有它所属外部类也就是MainActivity的引用。这条引用关系会一直保持直到消息得到处理，这样阻止了MainActivity被垃圾回收器回收，从而造成了内存泄漏。</p><h5 id="nbsp-nbsp-nbsp-nbsp-3-使用内部类创建AsyncTask"><a href="#nbsp-nbsp-nbsp-nbsp-3-使用内部类创建AsyncTask" class="headerlink" title="&nbsp; &nbsp; &nbsp; &nbsp; 3).使用内部类创建AsyncTask"></a>&nbsp; &nbsp; &nbsp; &nbsp; 3).使用内部类创建AsyncTask</h5><p>AsyncTask将持有其所在Activity的隐式引用。如果任务在Activity销毁之前还未完成，那么将导致Activity的内存资源无法被回收，从而造成内存泄漏。</p><p><strong>解决方法</strong>:<br>将匿名内部类或非静态内部类独立出来或者改写为静态内部类。另外如果需要在内部类里面调用外部Activity的方法，可以让静态内部类持有一个Activity的WeakReference，即持有一个外部类的弱引用<br>示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Activity&gt; mWeakReference;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">            mWeakReference = <span class="keyword">new</span> WeakReference&lt;Activity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;Activity&gt; weakActivity;</span><br><span class="line"></span><br><span class="line">        MyTask(Activity myActivity) &#123;</span><br><span class="line">            <span class="keyword">this</span>.weakActivity = <span class="keyword">new</span> WeakReference&lt;&gt;(myActivity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// do async stuff here</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.JELLY_BEAN_MR1)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Activity activity = weakActivity.get();</span><br><span class="line">            <span class="keyword">if</span> (activity == <span class="keyword">null</span></span><br><span class="line">                    || activity.isFinishing()</span><br><span class="line">                    || activity.isDestroyed()) &#123;</span><br><span class="line">                <span class="comment">// activity没了,就结束可以了</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续更新ui</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-集合容器中的内存泄露"><a href="#3-集合容器中的内存泄露" class="headerlink" title="3.集合容器中的内存泄露"></a>3.集合容器中的内存泄露</h4><p>我们通常把一些对象的引用加入到了集合容器（比如ArrayList）中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。</p><p><strong>解决方法</strong>：<br>在退出程序之前，将集合里的东西clear，然后置为null，再退出程序。</p><p>先写这么多，以后再遇到了再来更新</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;产生内存泄露的根本原因以及影响&quot;&gt;&lt;a href=&quot;#产生内存泄露的根本原因以及影响&quot; class=&quot;headerlink&quot; title=&quot;产生内存泄露的根本原因以及影响&quot;&gt;&lt;/a&gt;产生内存泄露的根本原因以及影响&lt;/h3&gt;&lt;p&gt;当一个对象已经不需要再使用本该被回收时，另外一个正在使用的对象持有它的引用从而导致它不能被回收，这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏&lt;br&gt;
    
    </summary>
    
      <category term="Android学习" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android子线程更新UI方法整理</title>
    <link href="http://yoursite.com/2018/11/24/Android%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0UI%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/11/24/Android子线程更新UI方法整理/</id>
    <published>2018-11-24T07:55:04.340Z</published>
    <updated>2019-01-23T07:15:48.383Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android子线程更新UI不是安全的"><a href="#Android子线程更新UI不是安全的" class="headerlink" title="Android子线程更新UI不是安全的"></a>Android子线程更新UI不是安全的</h4><p>Android的UI访问是没有加锁的，这样在多个线程访问UI是不安全的。Android中采用异步消息处理机制在处理多线程更新UI操作。<br><a id="more"></a></p><p>我觉得比较简易的主要有View.post() Handler.post() Activity.runOnUiThread()方法。另外可行的还有Handler.sendMessage()方法以及AsyncTask。<br>不过这两个方法定义为内部类的话，需要定义为静态内部类并保持对它外部类的弱引用，<br>否则有可能会造成内存泄露。然这样又会复杂化代码。所以本人觉得比较简单可行是最开始介绍的三种方法。</p><p>代码如下(布局文件中只有三个按钮):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button button2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button button1 = findViewById(R.id.button1);</span><br><span class="line">        button1.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        button2=findViewById(R.id.button2);</span><br><span class="line">        button2.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        Button button3 = findViewById(R.id.button3);</span><br><span class="line">        button3.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span>(v.getId())&#123;</span><br><span class="line">           <span class="keyword">case</span> R.id.button1:</span><br><span class="line">               <span class="comment">//通过Handler.post方法</span></span><br><span class="line">               <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       <span class="comment">//Looper.getMainLooper()方法用于获取主进程的Looper</span></span><br><span class="line">                       <span class="comment">//如果直接调用Handler参数为空的构造函数，默认是当前进程的Looper</span></span><br><span class="line">                       <span class="comment">//因为更新UI要回到主进程，故调用主进程的Looper</span></span><br><span class="line">                       Handler handler=<span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">                       handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                           <span class="meta">@Override</span></span><br><span class="line">                           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                               String str=<span class="string">"通过Handler.post方法更新UI成功"</span>;</span><br><span class="line">                               Toast.makeText(MainActivity.<span class="keyword">this</span>,str,Toast.LENGTH_SHORT).show();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).start();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> R.id.button2:</span><br><span class="line">               <span class="comment">//通过View.post方法</span></span><br><span class="line">               <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       button2.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                           <span class="meta">@Override</span></span><br><span class="line">                           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                               String str=<span class="string">"通过View.post方法更新UI成功"</span>;</span><br><span class="line">                               Toast.makeText(MainActivity.<span class="keyword">this</span>,str,Toast.LENGTH_SHORT).show();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).start();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> R.id.button3:</span><br><span class="line">               <span class="comment">//通过Activity.runOnUiThread方法</span></span><br><span class="line">               <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                           <span class="meta">@Override</span></span><br><span class="line">                           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                               String str=<span class="string">"通过runOnUiThread方法更新UI成功"</span>;</span><br><span class="line">                               Toast.makeText(MainActivity.<span class="keyword">this</span>,str,Toast.LENGTH_SHORT).show();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).start();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注:发送Toast消息也算更新UI。另外View.post()方法其中View的成员变量只要是当前布局的任意一个View都可以。</p><p>而通过观察这几个方法的源码发现更新UI都是基于异步消息处理机制的，都调用了boolean sendMessageDelayed(Message msg, long delayMillis)函数(第二个参数传入0)</p><p>例如Handler.post()方法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Android子线程更新UI不是安全的&quot;&gt;&lt;a href=&quot;#Android子线程更新UI不是安全的&quot; class=&quot;headerlink&quot; title=&quot;Android子线程更新UI不是安全的&quot;&gt;&lt;/a&gt;Android子线程更新UI不是安全的&lt;/h4&gt;&lt;p&gt;Android的UI访问是没有加锁的，这样在多个线程访问UI是不安全的。Android中采用异步消息处理机制在处理多线程更新UI操作。&lt;br&gt;
    
    </summary>
    
      <category term="Android学习" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android主活动onCreate函数创建子线程更新UI成功问题</title>
    <link href="http://yoursite.com/2018/11/23/Android%E4%B8%BB%E6%B4%BB%E5%8A%A8onCreate%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0UI%E6%88%90%E5%8A%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/11/23/Android主活动onCreate函数创建子线程更新UI成功问题/</id>
    <published>2018-11-23T08:08:16.186Z</published>
    <updated>2019-01-23T07:15:48.383Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主活动onCreate函数直接创建子线程更新UI成功"><a href="#主活动onCreate函数直接创建子线程更新UI成功" class="headerlink" title="主活动onCreate函数直接创建子线程更新UI成功"></a>主活动onCreate函数直接创建子线程更新UI成功</h3><p>在MainACtivity里onCreate()函数里面创建子线程更新UI竟然成功了<br><a id="more"></a></p><p>首先，直接在子线程中更新UI。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">final</span> TextView textView=findViewById(R.id.textView);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                textView.setText(<span class="string">"hello"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：布局文件中只有一个TextView</p><p>发现”hello”成功显示在TextView中。说明子线程更新UI成功。</p><p>然后我让子线程休息200ms后再进行更新，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">final</span> TextView textView=findViewById(R.id.textView);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                textView.setText(<span class="string">"hello"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发现TextView上并没有显示”hello”,说明子线程不能更新UI。是不是很奇怪？</p><p>原因是当访问UI时，ViewRoot的实现类ViewRootImpl会调用checkThread方法去检查当前访问UI的线程是哪个，如果不是UI线程则会抛出异常，更新UI失败。而第一次是我们直接在MainActivity的入口函数onCreate里面直接创建子线程跟新UI，这时候ViewRootImpl还来不及没有创建，以至于无法检查当前线程是否是主线程。</p><p>详细原因请见<a href="https://www.cnblogs.com/xuyinhuan/p/5930287.html" target="_blank" rel="noopener">Android中子线程真的不能更新UI吗?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主活动onCreate函数直接创建子线程更新UI成功&quot;&gt;&lt;a href=&quot;#主活动onCreate函数直接创建子线程更新UI成功&quot; class=&quot;headerlink&quot; title=&quot;主活动onCreate函数直接创建子线程更新UI成功&quot;&gt;&lt;/a&gt;主活动onCreate函数直接创建子线程更新UI成功&lt;/h3&gt;&lt;p&gt;在MainACtivity里onCreate()函数里面创建子线程更新UI竟然成功了&lt;br&gt;
    
    </summary>
    
      <category term="Android学习" scheme="http://yoursite.com/categories/Android%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
</feed>
