<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>hzscoder&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-24T12:01:37.298Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>hzscoder</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android学习之内存泄露</title>
    <link href="http://yoursite.com/2018/11/24/Android%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2/"/>
    <id>http://yoursite.com/2018/11/24/Android学习之内存泄露/</id>
    <published>2018-11-24T11:53:20.026Z</published>
    <updated>2018-11-24T12:01:37.298Z</updated>
    
    <content type="html"><![CDATA[<h3 id="产生内存泄露的根本原因以及影响"><a href="#产生内存泄露的根本原因以及影响" class="headerlink" title="产生内存泄露的根本原因以及影响"></a>产生内存泄露的根本原因以及影响</h3><p>当一个对象已经不需要再使用本该被回收时，<br>另外一个正在使用的对象持有它的引用从而导致它不能被回收，<br>这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏<br><a id="more"></a></p><p>内存泄漏是造成应用程序OOM的主要原因之一。<br>我们知道Android系统为每个应用程序分配的内存是有限的，<br>而当一个应用中产生的内存泄漏比较多时，<br>这就难免会导致应用所需要的内存超过系统分配的内存限额，<br>这就造成了内存溢出从而导致应用Crash，<br>可以借助MAT、LeakCanary等工具来检测应用程序是否存在内存泄漏</p><h4 id="1-资源未释放或对象内存过大"><a href="#1-资源未释放或对象内存过大" class="headerlink" title="1. 资源未释放或对象内存过大"></a>1. 资源未释放或对象内存过大</h4><p>程序长期保持某些资源，如Context、Cursor、IO 流的引用，<br>资源得不到释放造成内存泄露。<br>或者程序保存了多个耗用内存过大的对象（如Bitmap、XML 文件），<br>造成内存超出限制</p><h4 id="2-非静态内部类造成内存泄露"><a href="#2-非静态内部类造成内存泄露" class="headerlink" title="2.非静态内部类造成内存泄露"></a>2.非静态内部类造成内存泄露</h4><p>非静态内部类和匿名类内部类都会持有它们所属的外部类的引用，<br>但是静态内部类不会</p><h5 id="nbsp-nbsp-nbsp-nbsp-1-匿名内部类创建线程内存泄露"><a href="#nbsp-nbsp-nbsp-nbsp-1-匿名内部类创建线程内存泄露" class="headerlink" title="&nbsp; &nbsp; &nbsp; &nbsp; 1).匿名内部类创建线程内存泄露"></a>&nbsp; &nbsp; &nbsp; &nbsp; 1).匿名内部类创建线程内存泄露</h5><p>我们创建线程的时候通常采用内部类写法。但是我们思考一个问题:<br>假设我们在Activity里面创建了一个线程，但Thread里的run函数是一个很费时的操作。<br>当我们开启该线程后，Activity因为某些情况被重新创建<br>(例如用户将设备竖屏变为了横屏，一般情况下当屏幕转换时会重新创建Activity)。<br>按照我们的想法，原来的Activity应该会被销毁才对，然而事实上并非如此。<br>因为我们创建的Thread是Activity的内部类，所以Thread中保存了Activity的一个引用，<br>当Thread的run函数没有结束时，线程是不会被销毁的。<br>因此它所引用的原来的那个Activity也是不会被销毁，因此就出现了内存泄露的问题。</p><h5 id="nbsp-nbsp-nbsp-nbsp-2-创建内部类Handler内存泄露"><a href="#nbsp-nbsp-nbsp-nbsp-2-创建内部类Handler内存泄露" class="headerlink" title="&nbsp; &nbsp; &nbsp; &nbsp; 2).创建内部类Handler内存泄露"></a>&nbsp; &nbsp; &nbsp; &nbsp; 2).创建内部类Handler内存泄露</h5><p>示例代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">                handler.sendEmptyMessage(<span class="number">0x123</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当Android应用程序启动时，<br>该应用程序的主线程会自动创建一个Looper对象和与之关联的MessageQueue。<br>当主线程中实例化一个Handler对象后，<br>它就会自动与主线程Looper的MessageQueue关联起来。<br>所有发送到MessageQueue的Messag都会持有Handler的引用，<br>所以Looper会据此回调Handle的handleMessage()方法来处理消息。<br>只要MessageQueue中有未处理的Message，<br>Looper就会不断的从中取出并交给Handler处理。<br>另外，主线程的Looper对象会伴随该应用程序的整个生命周期。<br>所以当MainActivity结束时，未处理的消息持有handler的引用，<br>而handler又持有它所属的外部类也就是MainActivity的引用。<br>这条引用关系会一直保持直到消息得到处理，<br>这样阻止了MainActivity被垃圾回收器回收，从而造成了内存泄漏。</p><h5 id="nbsp-nbsp-nbsp-nbsp-3-使用内部类创建AsyncTask"><a href="#nbsp-nbsp-nbsp-nbsp-3-使用内部类创建AsyncTask" class="headerlink" title="&nbsp; &nbsp; &nbsp; &nbsp; 3).使用内部类创建AsyncTask"></a>&nbsp; &nbsp; &nbsp; &nbsp; 3).使用内部类创建AsyncTask</h5><p>AsyncTask将持有其所在Activity的隐式引用。如果任务在Activity销毁之前还未完成，<br>那么将导致Activity的内存资源无法被回收，从而造成内存泄漏。</p><p><strong>解决方法</strong>:<br>将匿名内部类或非静态内部类独立出来或者改写为静态内部类。<br>另外如果需要在内部类里面调用外部Activity的方法，<br>可以让静态内部类持有一个Activity的WeakReference，即持有一个外部类的弱引用<br>示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> WeakReference&lt;Activity&gt; mWeakReference;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyHandler</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">            mWeakReference = <span class="keyword">new</span> WeakReference&lt;Activity&gt;(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">extends</span> <span class="title">AsyncTask</span>&lt;<span class="title">Void</span>, <span class="title">Void</span>, <span class="title">Void</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> WeakReference&lt;Activity&gt; weakActivity;</span><br><span class="line"></span><br><span class="line">        MyTask(Activity myActivity) &#123;</span><br><span class="line">            <span class="keyword">this</span>.weakActivity = <span class="keyword">new</span> WeakReference&lt;&gt;(myActivity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Void <span class="title">doInBackground</span><span class="params">(Void... params)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// do async stuff here</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.JELLY_BEAN_MR1)</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostExecute</span><span class="params">(Void result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            Activity activity = weakActivity.get();</span><br><span class="line">            <span class="keyword">if</span> (activity == <span class="keyword">null</span></span><br><span class="line">                    || activity.isFinishing()</span><br><span class="line">                    || activity.isDestroyed()) &#123;</span><br><span class="line">                <span class="comment">// activity没了,就结束可以了</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续更新ui</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-集合容器中的内存泄露"><a href="#3-集合容器中的内存泄露" class="headerlink" title="3.集合容器中的内存泄露"></a>3.集合容器中的内存泄露</h4><p>我们通常把一些对象的引用加入到了集合容器（比如ArrayList）中，<br>当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。<br>如果这个集合是static的话，那情况就更严重了。<br><strong>解决方法</strong>：<br>在退出程序之前，将集合里的东西clear，然后置为null，再退出程序。</p><p>先写这么多，以后再遇到了再来更新</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;产生内存泄露的根本原因以及影响&quot;&gt;&lt;a href=&quot;#产生内存泄露的根本原因以及影响&quot; class=&quot;headerlink&quot; title=&quot;产生内存泄露的根本原因以及影响&quot;&gt;&lt;/a&gt;产生内存泄露的根本原因以及影响&lt;/h3&gt;&lt;p&gt;当一个对象已经不需要再使用本该被回收时，&lt;br&gt;另外一个正在使用的对象持有它的引用从而导致它不能被回收，&lt;br&gt;这导致本该被回收的对象不能被回收而停留在堆内存中，这就产生了内存泄漏&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android子线程更新UI方法整理</title>
    <link href="http://yoursite.com/2018/11/24/Android%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0UI%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/11/24/Android子线程更新UI方法整理/</id>
    <published>2018-11-24T07:55:04.340Z</published>
    <updated>2018-11-24T12:01:37.308Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Android子线程更新UI不是安全的"><a href="#Android子线程更新UI不是安全的" class="headerlink" title="Android子线程更新UI不是安全的"></a>Android子线程更新UI不是安全的</h4><p>Android的UI访问是没有加锁的，这样在多个线程访问UI是不安全的。<br>Android中采用异步消息处理机制在处理多线程更新UI操作。<br><a id="more"></a></p><p>我觉得比较简易的主要有View.post() Handler.post() Activity.runOnUiThread()方法。</p><p>另外可行的还有Handler.sendMessage()方法以及AsyncTask。<br>不过这两个方法定义为内部类的话，需要定义为静态内部类并保持对它外部类的弱引用，<br>否则有可能会造成内存泄露。然这样又会复杂化代码。</p><p>所以本人觉得比较简单可行是上面的三种方法。</p><p>代码如下(布局文件中只有三个按钮):<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Button button2;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Button button1 = findViewById(R.id.button1);</span><br><span class="line">        button1.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        button2=findViewById(R.id.button2);</span><br><span class="line">        button2.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">        Button button3 = findViewById(R.id.button3);</span><br><span class="line">        button3.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span>(v.getId())&#123;</span><br><span class="line">           <span class="keyword">case</span> R.id.button1:</span><br><span class="line">               <span class="comment">//通过Handler.post方法</span></span><br><span class="line">               <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       <span class="comment">//Looper.getMainLooper()方法用于获取主进程的Looper</span></span><br><span class="line">                       <span class="comment">//如果直接调用Handler参数为空的构造函数，默认是当前进程的Looper</span></span><br><span class="line">                       <span class="comment">//因为更新UI要回到主进程，故调用主进程的Looper</span></span><br><span class="line">                       Handler handler=<span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">                       handler.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                           <span class="meta">@Override</span></span><br><span class="line">                           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                               String str=<span class="string">"通过Handler.post方法更新UI成功"</span>;</span><br><span class="line">                               Toast.makeText(MainActivity.<span class="keyword">this</span>,str,Toast.LENGTH_SHORT).show();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).start();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> R.id.button2:</span><br><span class="line">               <span class="comment">//通过View.post方法</span></span><br><span class="line">               <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       button2.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                           <span class="meta">@Override</span></span><br><span class="line">                           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                               String str=<span class="string">"通过View.post方法更新UI成功"</span>;</span><br><span class="line">                               Toast.makeText(MainActivity.<span class="keyword">this</span>,str,Toast.LENGTH_SHORT).show();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).start();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">case</span> R.id.button3:</span><br><span class="line">               <span class="comment">//通过Activity.runOnUiThread方法</span></span><br><span class="line">               <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                       runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                           <span class="meta">@Override</span></span><br><span class="line">                           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                               String str=<span class="string">"通过runOnUiThread方法更新UI成功"</span>;</span><br><span class="line">                               Toast.makeText(MainActivity.<span class="keyword">this</span>,str,Toast.LENGTH_SHORT).show();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;).start();</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注:发送Toast消息也算更新UI。</p><p>而通过观察这几个方法的源码发现更新UI都是基于异步消息处理机制的，都调用了<br>boolean sendMessageDelayed(Message msg, long delayMillis)函数<br>(第二个参数传入0)</p><p>例如Handler.post()方法如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;Android子线程更新UI不是安全的&quot;&gt;&lt;a href=&quot;#Android子线程更新UI不是安全的&quot; class=&quot;headerlink&quot; title=&quot;Android子线程更新UI不是安全的&quot;&gt;&lt;/a&gt;Android子线程更新UI不是安全的&lt;/h4&gt;&lt;p&gt;Android的UI访问是没有加锁的，这样在多个线程访问UI是不安全的。&lt;br&gt;Android中采用异步消息处理机制在处理多线程更新UI操作。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android主活动onCreate函数创建子线程更新UI成功问题</title>
    <link href="http://yoursite.com/2018/11/23/Android%E4%B8%BB%E6%B4%BB%E5%8A%A8onCreate%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%AD%90%E7%BA%BF%E7%A8%8B%E6%9B%B4%E6%96%B0UI%E6%88%90%E5%8A%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2018/11/23/Android主活动onCreate函数创建子线程更新UI成功问题/</id>
    <published>2018-11-23T08:08:16.186Z</published>
    <updated>2018-11-24T12:01:37.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主活动onCreate函数直接创建子线程更新UI成功"><a href="#主活动onCreate函数直接创建子线程更新UI成功" class="headerlink" title="主活动onCreate函数直接创建子线程更新UI成功"></a>主活动onCreate函数直接创建子线程更新UI成功</h3><p>在MainACtivity里onCreate()函数里面创建子线程更新UI竟然成功了！！！<br><a id="more"></a><br>首先，直接在子线程中更新UI。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">final</span> TextView textView=findViewById(R.id.textView);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                textView.setText(<span class="string">"hello"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：布局文件中只有一个TextView</p><p>发现”hello”成功显示在TextView中。说明子线程更新UI成功。</p><p>然后我让子线程休息200ms后再进行更新，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        <span class="keyword">final</span> TextView textView=findViewById(R.id.textView);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">200</span>);</span><br><span class="line">                textView.setText(<span class="string">"hello"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后发现TextView上并没有显示”hello”,说明子线程不能更新UI。是不是很奇怪？</p><p>原因是当访问UI时，ViewRoot的实现类ViewRootImpl会调用checkThread方法去检查当前访问UI的线程是哪个，如果不是UI线程则会抛出异常，更新UI失败。而第一次是我们直接在MainActivity的入口函数onCreate里面直接创建子线程跟新UI，这时候ViewRootImpl还来不及没有创建，以至于无法检查当前线程是否是主线程。</p><p>详细原因请见<a href="https://www.cnblogs.com/xuyinhuan/p/5930287.html" target="_blank" rel="noopener">Android中子线程真的不能更新UI吗?</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;主活动onCreate函数直接创建子线程更新UI成功&quot;&gt;&lt;a href=&quot;#主活动onCreate函数直接创建子线程更新UI成功&quot; class=&quot;headerlink&quot; title=&quot;主活动onCreate函数直接创建子线程更新UI成功&quot;&gt;&lt;/a&gt;主活动onCreate函数直接创建子线程更新UI成功&lt;/h3&gt;&lt;p&gt;在MainACtivity里onCreate()函数里面创建子线程更新UI竟然成功了！！！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
